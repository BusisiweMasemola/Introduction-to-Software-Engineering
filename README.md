# Introduction-to-Software-Engineering
Assignment 1 on Software Engineering
Question 1:
Software engineering is the disciplined approach to designing, creating, and maintaining software systems, utilizing principles of engineering and computer science to develop diverse applications and solutions within the realm of information technology.
Question 2:
Software engineering is the branch of computer science that deals with the design, development, testing, and maintenance of software applications.
Software engineering differs from traditional programming primarily through its adoption of the Software Development Life Cycle (SDLC). While traditional programming often focuses on writing code to solve immediate problems, software engineering embraces a structured approach that spans the entire SDLC. This includes stages such as requirements gathering, design, implementation, testing, deployment, and maintenance. By following the SDLC, software engineering ensures a comprehensive and systematic development process, leading to high-quality, maintainable software solutions that meet long-term needs and requirements.
Question 3:
The Software Development Life Cycle (SDLC) is a systematic process that involves several phases. The first phase involves gathering stakeholder requirements to understand the software's function. The second phase involves designing the system architecture and specifications. The third phase involves coding the software, translating the design into code. The fourth phase involves testing the software to identify and fix any defects. The final phase is deployment, where the software is released to users. The final phase is maintenance, which involves ongoing support, updates, and maintenance to ensure the software's continued functionality and relevance.
The Waterfall Model is a sequential approach with well-defined requirements and less flexibility for changes. It's suitable for projects with stable requirements and a clear understanding of the end product. The Agile Model, on the other hand, is an iterative and incremental approach, focusing on collaboration, adaptability, and customer involvement. It allows for flexibility and accommodates changes throughout the development process, making it ideal for projects with evolving requirements.
Question 4:
“Agile is an iterative approach to software development, emphasizing flexibility and collaboration among cross-functional teams. It focuses on delivering small, incremental releases, adapting to changes throughout the development process. In contrast, Waterfall is a linear and sequential approach, where each phase must be completed before moving to the next. Changes are difficult to incorporate once a phase is completed. Agile promotes adaptability and customer feedback, while Waterfall provides a structured plan but may struggle with accommodating changes late in the development cycle.” (Team, n.d.) When it comes to software development methodologies, Agile and Waterfall are two prominent approaches that offer distinct advantages and challenges. Understanding the key characteristics, pros, and cons of each methodology is crucial for choosing the most suitable approach for your project.

Agile:
1. Iterative and Incremental: Agile focuses on iterative development, where software is developed in small, incremental cycles.
2. Adaptive: Agile allows for flexibility and changes throughout the development process, responding to feedback quickly.
3. Customer Collaboration: Customers are involved throughout the process, providing feedback and guiding the development.
4. Cross-functional Teams: Teams are usually small and cross-functional, promoting collaboration and communication.

Waterfall:
1. Sequential: Waterfall follows a sequential approach, with each phase (requirements, design, implementation, testing, deployment) completed before moving to the next.
2. Rigid: Changes are difficult to implement once a phase is completed, as each phase builds upon the previous one.
3. Documentation-heavy: Waterfall relies heavily on documentation, with detailed requirements and design documents created upfront.
4. Less Customer Involvement: Customer involvement tends to be limited to the requirements phase, with less interaction during other stages.

Key Differences:
- Flexibility: Agile is more flexible and adaptable to change, while Waterfall is rigid and less accommodating to changes once the project has started.
-Customer Involvement: Agile encourages continuous customer involvement and feedback, while Waterfall typically involves customers primarily during the requirements phase.
-Risk Management: Agile mitigates risks by breaking the project into smaller iterations, allowing for early detection and correction of issues, whereas Waterfall may lead to higher risks due to its sequential nature.

Preferred Scenarios:
- Agile: Preferred for projects where requirements are likely to change, or where rapid delivery and feedback are crucial, such as in startups, research, or dynamic markets.
- Waterfall: Preferred for projects with clearly defined and stable requirements, where predictability and strict control over the process are more important than flexibility, such as in regulatory environments or large-scale infrastructure projects.
Question 5:
Requirements engineering is critical to the software development life cycle (SDLC) because it defines and understands the wants and aspirations of the customer while also improving communication between stakeholders and the development team. It assists software engineers in better understanding the topic they are working on and facilitates requirements validation. Requirements engineering responsibilities include requirement analysis, elicitation, documentation, conciliation, and validation. The use of automated requirement engineering technologies increases communication and cooperation between client stakeholders and engineers, even when they are not in the same geographical area. It also makes it easier to write accurate and thorough test requests and test cases. Overall, requirements engineering guarantees that software requirements are carefully collected and helps to create safe and successful software solutions that match customer demands and expectations.

The process typically involves several stages:
1. Elicitation: Gathering requirements from stakeholders, which may include users, customers, managers, and developers. This can involve interviews, surveys, workshops, and observations.
2. Analysis: Analyzing the collected requirements to ensure they are clear, complete, and consistent. This involves prioritizing requirements, identifying dependencies, and resolving conflicts.
3. Specification: Documenting the requirements in a clear and unambiguous manner. This may involve using various techniques such as use cases, user stories, and formal specifications.
4. Validation: Ensuring that the documented requirements accurately reflect the needs of the stakeholders. This can involve reviews, prototyping, and simulations.

5. Management: Managing changes to the requirements throughout the software development lifecycle. This includes tracking changes, assessing their impact, and communicating updates to stakeholders.

Requirements engineering is important in the software development lifecycle because it lays the foundation for the entire development process. By clearly defining the goals and constraints of the system, it helps to reduce the risk of project failure, improve communication among stakeholders, and increase the likelihood of delivering a product that meets the needs of the users.
As for software design principles, they include concepts like modularity, abstraction, encapsulation, cohesion, coupling, separation of concerns, and others. These principles guide the design of software systems to make them more maintainable, scalable, and adaptable. They promote code reusability, readability, and flexibility, ultimately leading to higher quality software products.
Question 6:
In software design, modularity is the process of disassembling a system into more manageable, autonomous modules or components that may be independently created, tested, and maintained. Every module fulfills a particular purpose or symbolizes a different facet of the system's operation. This methodology facilitates code reuse, adaptability, and scalability by enabling modules to be readily replaced, modified, or added without impacting the system as a whole. Because developers may work on multiple modules at the same time without interfering with each other's work, it also makes cooperation easier.
Yes, modularity can significantly enhance both maintenance and scalability of software. By dividing software into distinct modules, developers can manage, update, and scale parts of the application independently, leading to more efficient maintenance and easier scalability.

Maintenance Efficiency: Isolating issues within specific modules simplifies debugging and updating processes.
Scalability: Modular designs allow for adding, updating, or scaling specific modules without impacting the entire system. 
Adaptability: Modular systems can more readily adapt to changing requirements or technologies.
Collaborative Development: Modularity supports concurrent development, where multiple teams can work on different modules simultaneously.
Question 7:
Unit tests involve testing individual methods and functions within a software application, providing a low-level assessment close to the source code. They are relatively inexpensive to automate and execute quickly, often facilitated by continuous integration servers.
Integration tests, on the other hand, ensure that various modules or services within the application function harmoniously. This could entail assessing interactions with databases or verifying the seamless operation of microservices. Integration tests are more resource-intensive as they necessitate multiple components of the application to be operational simultaneously.
System Testing: System testing evaluates the behavior of the entire system as a whole. It validates that the software meets its functional and non-functional requirements.
Acceptance Testing: Acceptance testing determines whether the software meets the expectations and requirements of stakeholders. It typically involves testing the software in a real-world environment to ensure it delivers the desired outcomes.
Testing is crucial in software development because it helps identify defects early in the development process, reducing the cost and effort required to fix them later. It ensures that the software meets its intended requirements and functions correctly under various conditions. Additionally, testing helps build confidence in the software's quality and reliability, ultimately leading to increased user satisfaction and trust.
Version Control Systems (VCS) are tools that track changes to source code and facilitate collaboration among developers working on the same codebase. They allow developers to manage different versions of code, track changes, and merge modifications made by multiple contributors. Popular VCS include Git, SVN (Subversion), and Mercurial. VCS are essential in software development as they help maintain code integrity, enable collaboration, and provide a history of changes for troubleshooting and auditing purposes.
Question 8:
Every change made to the code is tracked by version control software in a unique type of database. When an error occurs, engineers may go back in time and compare previous iterations of the code to assist correct the problem with the least amount of disturbance to the other members of the team. Software code tracking and management is referred to as version control, or source control. Software teams may better manage source code changes over time with the use of version control systems. Version control solutions facilitate quicker and more intelligent software teamwork as development environments have advanced.
Many different businesses make extensive use of version control systems (VCS). Git is a distributed system that is lightweight, quick, and allows for branching and merging. Both commercial and open-source applications frequently use it. Atomic commits, branching, tagging, and tracking of changes to files and directories are all possible with Subversion (SVN), a centralized system. Finally, Mercurial is a distributed system with a performance and user-friendliness focus, akin to Git. Because it allows distributed workflows, branching, and merging, it may be used for both small and big projects.

Question 9:
A software project manager plays a crucial role in overseeing the planning, execution, and delivery of software projects. They are responsible for ensuring that the project meets its objectives within the constraints of time, budget, and quality.
Key Responsibilities

Project Planning: Developing project plans, defining scope, creating schedules, and allocating resources.
Team Management: Leading and managing the project team, assigning tasks, and ensuring effective communication.
Risk Management: Identifying and mitigating potential risks that could impact project success.
Stakeholder Communication: Keeping stakeholders informed about project progress, issues, and changes.
Quality Assurance: Ensuring that the software meets quality standards and adheres to requirements.
Budget and Resource Management: Monitoring project expenses and managing resources efficiently.

Challenges Faced
Scope Creep: Managing changes in project scope without affecting the project timeline and budget.
Resource Allocation: Balancing the allocation of resources to meet project demands.
Communication: Ensuring effective communication among team members, stakeholders, and other project participants.
Risk Management: Identifying and addressing potential risks that could impact project delivery.
Time Management: Meeting project deadlines and milestones in the face of unexpected challenges.
To summaries, the successful execution of software projects is largely dependent on the software project manager's ability to successfully manage resources, risks, and communication while sticking to project limits.
Question 10:
Software maintenance is an integral part of the software life cycle that involves modifying and updating software after it has been deployed. The goal of maintenance is to correct faults, improve performance or other attributes, and adapt the software to a changing environment throughout its lifetime.
Maintenance begins after system deployment and commonly occupies over half of the total lifecycle costs. Maintenance is required to keep software operational and meet user needs over time. As requirements evolve and the software ages, maintenance activities become necessary to sustain satisfactory operation. 
For software systems to remain viable and successful over the long term, maintenance is essential. By preventing system malfunctions and downtime, it helps guarantee that software programs continue to function dependably and as intended throughout time. Software programs may also be made to adapt to changes in corporate demands, technological advancements, and user preferences through maintenance efforts, which guarantees their continuous relevance and usability. By enhancing software systems' value to stakeholders and extending their lifespan, they also safeguard investment. Additionally, by enabling them to constantly iterate and enhance their products, software maintenance helps businesses stay competitive by keeping them ahead of the competition and addressing client requirements. All things considered, software maintenance is crucial for businesses to get the most out of their software investments and maintain their competitiveness.

In order to guarantee ethical, just, and practices that are in line with society ideals, software engineering incorporates ethical concerns. Important ethical factors to take into account are user autonomy and permission, privacy and data protection, security, inclusiveness, transparency, intellectual property rights, professional accountability, prejudice and fairness, and societal effect. Making sure that user data is gathered, saved, and handled safely; following laws such as the General Data Protection Regulation; and developing software that is resistant to intrusions and weaknesses. It's also critical to follow accessibility guidelines, adhere to professional norms of behaviour, and design software that is inclusive and accessible. Ultimately, in order to guarantee justice and equity in the development and application of software, biases in algorithms and data sets must be addressed. Software engineers may contribute to the creation of useful and effective software that upholds and advances the ethical

Question 11:
Five examples of ethical issues and how developers can address them:
•	addictive design;
•	corporate ownership of personal data;
•	algorithmic bias;
•	weak cyber security and personally identifiable information (PII) protection; and
•	overemphasis on features
“Addictive design- For example, The problem is that some teams craft apps that people love too much. There is an ethical concern about the role of digital platforms, such as social media.” (Lawton, 2020)
corporate ownership of personal data- For example, Developers face a hard decision regarding personal data and software design. They can create systems to exploit user data with the understanding that the liability lies with the organization, or they can raise concerns but face potential penalization for going against the project's aims.
algorithmic bias;- For example, in the book, Race After Technology, Ruha Benjamin raised some concerns about a case where developers failed to include Black people's voices in training AI speech recognition algorithms, under the belief that fewer Black people would use the app.
